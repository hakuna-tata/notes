## Chrome架构
早期Chrome浏览器单进程时代：  
> 浏览器的所有功能模块都运行在同一个进程里，包括网络、插件、JavaScript运行环境、渲染引擎和页面等，因此会导致浏览器出现不稳定、不流畅和不安全等原因。
1. **不稳定**：⼀个插件的意外崩溃或者渲染引擎的崩溃会引起整个浏览器的崩溃。
2. **不流畅**：⻚⾯的渲染模块、JavaScript执⾏环境以及插件都是 运⾏在同⼀个线程中的，这就意味着同⼀时刻只能有⼀个模块可以执⾏。
3. **不安全**：插件和⻚⾯脚本获取系统权限之后可以对你的电脑做⼀些恶意的事情引发安全问题。

现代浏览器多进程架构解决了早期浏览器的各项问题：
1. **解决不稳定**：进程是相互隔离的，所以当⼀个⻚⾯或者插件崩溃时，影响到的仅仅是当前的⻚⾯进程或者插件进程，并不会影响到浏览器和其他⻚⾯，这就完美地解决了⻚⾯或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。
2. **解决不流畅**：JavaScript也是运⾏在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染⻚⾯，⽽并不会影响浏览器和其他⻚⾯，因为其他⻚⾯的脚本是运⾏在它们⾃⼰的渲染进程中的。
3. **解决不安全**：多进程架构可以使⽤安全沙箱。


现代Chrome浏览器多进程时代：  
1. **浏览器主进程**：主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。
2. **GPU进程**：实现3D CSS的效果。
3. **⽹络进程**：负责⻚⾯的⽹络资源加载。
4. **多个渲染进程**：核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎 Blink 和 JavaScript 引擎V8都是运⾏在该进程中，默认情况下，Chrome会为每个Tab标签创建⼀个渲染进程。出于安全考虑，渲染进程都是运⾏在沙箱模式下。
5. **多个插件进程**：负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。

打开一个Chrome页面进行测试：
<img src="/notes/browser/chromeProcess.png" style="display:block;margin:0 auto"/>
> 所以打开1个⻚面⾄少需要1个浏览器进程、1个GPU进程、1个⽹络进程以及1个渲染进程，共4个；如果打开的⻚⾯有运⾏插件的话，还需要再加上1个插件进程。


## 导航流程  
**在浏览器里，从输⼊URL到页面展示，这中间发生了什么？** 这是一道又难又经典的面试题，因为它涉及了网络，操作系统，Web等一系列的知识。因此本节就来探索一下这些知识点。
> [知名github repo 从浏览器地址栏输入google.com按下回车后会发生什么......](https://github.com/alex/what-happens-when)

套用极客时间李兵老师的《浏览器工作原理与实践》从输入 URL 到页面展示完整流程示意图”：
<img src="/notes/browser/urlToRender.png" style="display:block;margin:0 auto"/>

1. **用户从浏览器进程里输入请求信息** （地址栏会判断输入的关键字是搜索内容，还是请求的的URL）
  - 1 - 1 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，合成新的带搜索关键字的URL。
  - 1 - 1 如果判断输入内容符合URL规则，地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

2. **浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，然后就会进行URL请求过程**
  - 2 - 1 网络进程会查找本地是否缓存了该资源，如有缓存，直接返回资源给浏览器进程。如果没有则进入网络请求流程。
  - 2 - 2 进行DNS解析（完整流程可以查看上述github仓库）
  - 2 - 3 协议如果是HTTPS，还需要建议TLS连接
  - 2 - 4 利用ip地址和服务器建立tcp连接（可以去补充计算机网络知识）
  - 2 - 5 构建请求头信息
  - 2 - 6 发送请求头信息
  - 2 - 7 服务器响应后，网络进程接收响应头信息，并解析响应内容
  - 2 - 8 检查状态码，如果是301/302，则进行重定向，从Location中自动读取地址，重新进行2的循环。如果是200，则继续处理请求
  - 2 - 9 检查响应类型Content-Type

3. **准备渲染进程**
  - 3 - 1 浏览器进程检查当前url和之前打开的渲染进程是否在同一站点（sameSite[根域名和协议相同]），如果相同，则复用渲染进程。如果不同，则开启新的渲染进程
  > 如果页面使用了rel = "noopener noreferrer"，新打开的子窗口是不会共享父窗口的渲染进程（安全问题）

  <img src="/notes/browser/startRender.png" style="display:block;margin:0 auto"/>

4. **提交文档：**
  - 4 - 1 渲染进程准备好后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中。浏览器进程向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  - 4 - 2 渲染进程接收完数据后，向浏览器进程发送“确认提交”
  - 4 - 3 浏览器进程接收到确认消息后会更新浏览器界面：安全状态，地址栏的url，前进后退的历史状态，并更新Web页面等
  > 上述4个宏观步骤很好的解释了为什么在浏览器的地址栏里面输入url地址后，之前的页面不会立马消失，而是要加载一会儿才会更新页面。

5. **渲染阶段**
  - 5 - 1 构建DOM树（浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构--DOM树）
  - 5 - 2 样式计算（浏览器无法理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行转换操作，将CSS文本转换为浏览器可以理解的结构--styleSheets）
  > 浏览器控制台输入document.styleSheets测试计算出DOM树所有节点的样式

  <img src="/notes/browser/styleSheets.png" style="display:block;margin:0 auto"/>

  - 5 - 3 创建布局树Layout（生成完DOM树和DOM样式，接下来就需要计算出DOM树中可见元素的几何位置，生成一颗只包含可见元素的布局树）
  - 5 - 4 对布局树进行分层Layer，特定的节点生成专用的图层，并生成一棵对应的图层树（position：fixed，z-index,opacity,filter等）
  - 5 - 5 渲染引擎对图层树中的每个图层进行绘制，生成绘制列表（绘制列表中的指令非常简单，就是让其执行⼀个简单的绘制操作，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程）
  - 5 - 6 合成线程将图层分层图块tile，并在光栅格化raster线程池中将图块转换成位图
  > 在有些情况下，有的图层可以很⼤，比如有的页面使⽤滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到⻚⾯的很小⼀部分，所以在这种情况下，要绘制出所有图层内容的话，就会产⽣太⼤的开销，⽽且也没有必要。 基于这个原因
  > **合成线程会将图层划分为图块tile,合成线程会通过栅格化操作，按照视口附近的图块优先生成位图**

  - 5 - 7 合成线程发送绘制图块命令DrawQuad给浏览器进程
  - 5 - 8 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上
  > 使用极客时间李兵老师《浏览器工作原理与实践》中完整的渲染流水线示意图总结一下

   <img src="/notes/browser/detailRender.png" style="display:block;margin:0 auto"/>

## 重排 重绘 合成

1. **重排：更新了元素的几何属性**
> 如果JS或者CSS修改某些元素的几何位置属性，例如修改宽度，高度等，渲染引擎会触发重新布局，解析一系列子阶段。

<img src="/notes/browser/reflow.png" style="display:block;margin:0 auto"/>


2. **重绘：更新元素的绘制属性**
> 如果JS或者CSS修改某些元素的背景颜色等，渲染引擎将省去了布局和分层阶段，所以执行效率会比重排操作要高些。

<img src="/notes/browser/repaint.png" style="display:block;margin:0 auto"/>

3. **合成：直接合成阶段**
> 如果更改一个既不用布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，相对于重排和重绘，合成能大大提升绘制效率。

<img src="/notes/browser/merge.png" style="display:block;margin:0 auto"/>

**减少重排重绘方法：**
- 使用 class 操作样式，而不是频繁操作 style
- 避免使用 table 布局
- 批量操作 dom，例如 createDocumentFragment，使用React，Vue框架等
- Debounce window resize 事件
- will-change: transform，opacity 做优化
- 对 dom 属性的读写要分离