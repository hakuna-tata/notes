## 概述
传输层为 ***应用程序之间*** 提供 ***端到端*** 的逻辑通信。

## UDP 协议和 TCP 协议
1. **UDP（User Datagram Protocol）**
> UDP 是无连接的 （即不需要建立连接，减少了开销和发送数据的时延）   
> UDP 不提供可靠交付（即不需要维护复杂的连接状态）  
> UDP 是面向报文传输的（即应用层交给 UDP 多长的报文，UDP就照样发送）  
> UDP 支持 N 对 N 的交互通信  
> .....

2. **TCP（Transmission Control Protocol）**
> TCP 是面向连接的（即TCP三次握手）  
> TCP 提供可靠交付（即传输的数据无差错、不丢失、不重复）  
> TCP 一条连接只能连接通信两端唯一的端点（即套接字：IP + port）  
> TCP 面向字节流传输（即把数据拆分成一连串无结构的字节流）   
> TCP 提供全双工通信（即通信双方在任何时候都能发送数据）     
> ......

## UDP 首部和 TCP 首部
1. **UDP数据报：（首部字段 + 数据字段）**

    <img src="/notes/network/transportLayer/udp.png" style="display:block;margin:0 auto"/>

    - 比较清晰明了不需要做笔记
2. **TCP报文段：（首部字段 + 数据字段）**

    <img src="/notes/network/transportLayer/tcp.png" style="display:block;margin:0 auto"/>

    - 序号（Sequence number）：是指本报文段第一个字节的序号，TCP连接中传送的字节流中的每一个字节都按顺序编号，主要是为了保证数据包按正确的顺序组装。  
    - 确认号（Acknowledgment number）：是期望收到对方下一个报文段的第一个数据字节的序号。  
    - 常用标记位：
      - 1.确认ACK: 当 ACK = 1时确认号字段才有效。也就是说建立连接后传送报文段都必须把 ACK = 1。
      - 2.同步SYN: 建立一个连接时用来同步的序号。当 SYN = 1 而 ACK = 0表明是连接请求报文，当同意建立连接则在响应报文中使 SYN = 1 和 ACK = 1。
      - 3.终止FIN：用来释放一个连接。当 FIN = 1表明此报文段的发送方的数据都已经发送完毕，并要求释放传输连接。
    - 窗口大小：窗口值告诉对方目前允许对方发送的数据量。是因为双方的接收缓存空间是有限的。
    - 常用的选项：
      - 1.TimeStamp：TCP 时间戳。
      - 2.MSS: 规定一个最大报文段长度。
      - 3.SACK: 选择确认选项。
      - 4.Window Scale： 窗口缩放选项。

## TCP 的传输连接管理
1. **TCP 的三次握手连接**
  <img src="/notes/network/transportLayer/handshake.jpg" style="display:block;margin:0 auto"/>
    - 双方开始都处于 **CLOSED** 状态。服务端开始监听某个端口，进入了 **LISTEN** 状态。
    - 客户端主动发起连接，请求报文段中把首部的**同步位 SYN 置为1**同时选择一个**初始序号 seq = x**，自己变成 **SYN-SENT** 状态。【不能携带数据】
    - 服务端收到连接请求后，如果同意建立连接则向客户端发送确认。确认报文段中把首部的 **SYN位 和 ACK位 置为1**，**确认号是 ack = x + 1**同时也选择一个**初始序号 seq = y**，自己变成 **SYN-RCVD** 状态。【不能携带数据】
    - 之后客户端再次向服务端给出确认。确认报文段中把 **ACK位 置为1**，**确认号 ack = y + 1**，**序号变为 seq = x + 1**，自己变为 **ESTABLISHED** 状态。【ACK报文段可以携带数据】
    - 服务端接收到客户端确认后，也进入 **ESTABLISHED** 状态。

    **为什么不是二次握手呢？**  
      - 主要是为了防止已失效的连接请求报文段突然又传送给服务段，因为产生错误。
    > 异常情况：如果客户端发出的一个连接请求报文没有丢失，只是在某些网络结点长时间**滞留**了，直到连接释放后的某个时间才到达服务端。本来这是一个已经失效的报文段，但是服务端会误以为这是客户端发出一次新的连接请求，随后又同意建立连接。所以这就带来了连接资源的浪费了。

    **为什么不是四次握手呢？**
      - 三次握手已经足够确认客户端服务端发送和接收的能力，再多用处就不大了。

2. **TCP 的四次挥手释放**
  <img src="/notes/network/transportLayer/release.jpg" style="display:block;margin:0 auto"/>
    - 双方开始都处于 **ESTABLISHED** 状态。
    - 客户端主动发出连接释放报文段，把释放报文段中首部的**终止控制位 FIN 置为1**同时选择一个**序号 seq = u**，自己变成 **FIN-WAIT-1** 状态。
    - 服务端收到释放报文段后发出确认，确认报文段中把首部的 **ACK位 置为1**，**确认号 ack = u + 1**同时选择一个**序号 seq = v**，自己变为 **CLOSE-WAIT** 状态。【半关闭状态，即客户端不向服务端发送数据了】
    - 客户端收到服务端的确认后，自己变为 **FIN-WAIT-2** 状态，接着等待服务端发出的连接释放报文段。
    - 服务端发出连接释放报文段，把释放报文段中首部的**终止控制位 FIN 置为1**，**确认号还是 ack = u + 1**同时**序号 seq = w**（因为半关闭状态服务端可能还向客户端发送了数据），自己进入**LAST-ACK**状态。
    - 客户端接收到释放报文段后发出确认，确认报文段中把首部的 **ACK位 置为1**，**确认号 ack = w + 1**同时**序号 seq = u + 1**，自己变为 **TIME-WAIT** 状态。
    - 服务端接收到客户端确认后变为 **CLOSED** 状态，而客户端需等待**2个MSL**后才进入 **CLOSED** 状态。

    **为什么客户端CLOSED前需等待2MSL（最长报文段寿命）**  
      - 1. 为了保证客户端发送的最后一个 **ACK 报文段**能够到达服务端。
    > 异常情况：如果客户端发送的最后这个 ACK 报文段丢失了，就会造成 LAST-ACK 状态的服务端收不到对客户端发送的 FIN + ACK 报文段的确认。服务端就会超时重传这个 FIN + ACK 报文段，如果客户端发送最后一个 ACK 报文段就直接进入 CLOSED 状态就无法接收服务端重传的报文了，服务端就无法按照正常步骤进入 CLOSED 状态。如果有这个等待2MSL，客户端就可以重传一次确认，最后都可以正常进入 CLOSED 状态。

      - 2. 确保下一个新的连接中不会出现这次连接的报文段。
    > 经过2MSL可以使得本连接持续的时间内所产生的所有报文段都从网络中消失，这样下个新的连接中不会出现这种旧的连接请求报文段。

## 可靠传输的工作原理
1. **停止等待协议**

2. **连续ARQ（Automatic Repeat reQuest）协议**