## 概述
传输层为 ***应用程序之间*** 提供 ***端到端*** 的逻辑通信。

## UDP 协议和 TCP 协议
1. **UDP（User Datagram Protocol）**
> UDP 是无连接的 （即不需要建立连接，减少了开销和发送数据的时延）   
> UDP 不提供可靠交付（即不需要维护复杂的连接状态）  
> UDP 是面向报文传输的（即应用层交给 UDP 多长的报文，UDP就照样发送）  
> UDP 支持 N 对 N 的交互通信  
> .....

2. **TCP（Transmission Control Protocol）**
> TCP 是面向连接的（即TCP三次握手）  
> TCP 提供可靠交付（即传输的数据无差错、不丢失、不重复）  
> TCP 一条连接只能连接通信两端唯一的端点（即套接字：IP + port）  
> TCP 面向字节流传输（即把数据拆分成一连串无结构的字节流）   
> TCP 提供全双工通信（即通信双方在任何时候都能发送数据）     
> ......

## TCP 的传输连接管理
1. **TCP 的三次握手连接**
  <img src="/notes/network/transportLayer/handshake.jpg" style="display:block;margin:0 auto"/>
    - 双方开始都处于 **CLOSED** 状态。服务端开始监听某个端口，进入了 **LISTEN** 状态。
    - 客户端主动发起连接，请求报文段中携带**同步位 SYN = 1**同时选择一个**初始序号 seq = x**，自己变成 **SYN-SENT** 状态。【不能携带数据】
    - 服务端收到连接请求后，如果同意建立连接则向客户端发送确认。确认报文段中把 **SYN位 和 ACK位 置为1**，**确认号是 ack = x + 1**同时也选择一个**初始序号 seq = y**，自己变成 **SYN-RCVD** 状态。【不能携带数据】
    - 之后客户端再次向服务端给出确认。确认报文段中把 **ACK 置为1**，**确认号 ack = y + 1**，**序号变为 seq = x + 1**，自己变为 **ESTABLISHED** 状态。【ACK报文段可以携带数据】
    - 服务端接收到客户端确认后，也进入 **ESTABLISHED** 状态。

    **为什么不是二次握手呢？**  
      - 主要是为了防止已失效的连接请求报文段突然又传送给服务段，因为产生错误。
    > 异常情况：如果客户端发出的一个连接请求报文在某些网络结点长时间**滞留**了，直到连接释放后的某个时间才到达服务端。本来这是一个已经失效的报文段，但是服务端会误以为这是客户端发出一次新的连接请求，随后又同意建立连接。所以这就带来了连接资源的浪费了。

    **为什么不是四次握手呢？**
      - 三次握手已经足够确认客户端服务端发送和接收的能力，再多用处就不大了。

2. **TCP 的四次挥手释放**