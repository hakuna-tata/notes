(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{221:function(v,_,t){"use strict";t.r(_);var r=t(0),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("传输层为 "),t("em",[t("strong",[v._v("应用程序之间")])]),v._v(" 提供 "),t("em",[t("strong",[v._v("端到端")])]),v._v(" 的逻辑通信。")]),v._v(" "),t("h2",{attrs:{id:"udp-协议和-tcp-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp-协议和-tcp-协议"}},[v._v("#")]),v._v(" UDP 协议和 TCP 协议")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("UDP（User Datagram Protocol）")])])]),v._v(" "),t("blockquote",[t("p",[v._v("UDP 是无连接的 （即不需要建立连接，减少了开销和发送数据的时延）"),t("br"),v._v("\nUDP 不提供可靠交付（即不需要维护复杂的连接状态）"),t("br"),v._v("\nUDP 是面向报文传输的（即应用层交给 UDP 多长的报文，UDP就照样发送）"),t("br"),v._v("\nUDP 支持 N 对 N 的交互通信"),t("br"),v._v("\n.....")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[v._v("TCP（Transmission Control Protocol）")])])]),v._v(" "),t("blockquote",[t("p",[v._v("TCP 是面向连接的（即TCP三次握手）"),t("br"),v._v("\nTCP 提供可靠交付（即传输的数据无差错、不丢失、不重复）"),t("br"),v._v("\nTCP 一条连接只能连接通信两端唯一的端点（即套接字：IP + port）"),t("br"),v._v("\nTCP 面向字节流传输（即把数据拆分成一连串无结构的字节流）"),t("br"),v._v("\nTCP 提供全双工通信（即通信双方在任何时候都能发送数据）"),t("br"),v._v("\n......")])]),v._v(" "),t("h2",{attrs:{id:"udp-首部和-tcp-首部"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp-首部和-tcp-首部"}},[v._v("#")]),v._v(" UDP 首部和 TCP 首部")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("UDP数据报：（首部字段 + 数据字段）")])]),v._v(" "),t("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/notes/network/transportLayer/udp.png"}}),v._v(" "),t("ul",[t("li",[v._v("比较清晰明了不需要做笔记")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("TCP报文段：（首部字段 + 数据字段）")])]),v._v(" "),t("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/notes/network/transportLayer/tcp.png"}}),v._v(" "),t("ul",[t("li",[v._v("序号（Sequence number）：是指本报文段第一个字节的序号，TCP连接中传送的字节流中的每一个字节都按顺序编号，主要是为了保证数据包按正确的顺序组装。")]),v._v(" "),t("li",[v._v("确认号（Acknowledgment number）：是期望收到对方下一个报文段的第一个数据字节的序号。")]),v._v(" "),t("li",[v._v("常用标记位：\n"),t("ul",[t("li",[v._v("1.确认ACK: 当 ACK = 1时确认号字段才有效。也就是建立连接后传送报文段都必须把 ACK = 1。")]),v._v(" "),t("li",[v._v("2.同步SYN: 建立一个连接时用来同步的序号。当 SYN = 1 而 ACK = 0表明是连接请求报文，当同意建立连接则在响应报文中使 SYN = 1 和 ACK = 1。")]),v._v(" "),t("li",[v._v("3.终止FIN：用来释放一个连接。当 FIN = 1表明此报文段的发送方的数据都已经发送完毕，并要求释放传输连接。")])])]),v._v(" "),t("li",[v._v("窗口大小：窗口值告诉对方目前允许对方发送的数据量。是因为双方的接收缓存空间是有限的。")]),v._v(" "),t("li",[v._v("常用的选项：\n"),t("ul",[t("li",[v._v("1.TimeStamp：TCP 时间戳。")]),v._v(" "),t("li",[v._v("2.MSS: 规定一个最大报文段长度。")]),v._v(" "),t("li",[v._v("3.SACK: 选择确认选项。")]),v._v(" "),t("li",[v._v("4.Window Scale： 窗口缩放选项。")])])])])])]),v._v(" "),t("h2",{attrs:{id:"tcp-的传输连接管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的传输连接管理"}},[v._v("#")]),v._v(" TCP 的传输连接管理")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("TCP 的三次握手连接")]),v._v(" "),t("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/notes/network/transportLayer/handshake.jpg"}})]),v._v(" "),t("ul",[t("li",[v._v("双方开始都处于 "),t("strong",[v._v("CLOSED")]),v._v(" 状态。服务端开始监听某个端口，进入了 "),t("strong",[v._v("LISTEN")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("客户端主动发起连接，请求报文段中把首部的"),t("strong",[v._v("SYN位 置为1")]),v._v("，自己变成 "),t("strong",[v._v("SYN-SENT")]),v._v(" 状态。【不能携带数据】")]),v._v(" "),t("li",[v._v("服务端收到连接请求后，如果同意建立连接则向客户端发送确认。确认报文段中把首部的 "),t("strong",[v._v("SYN位 和 ACK位 置为1")]),v._v("，自己变成 "),t("strong",[v._v("SYN-RCVD")]),v._v(" 状态。【不能携带数据】")]),v._v(" "),t("li",[v._v("之后客户端再次向服务端给出确认。确认报文段中把 "),t("strong",[v._v("ACK位 置为1")]),v._v("，自己变为 "),t("strong",[v._v("ESTABLISHED")]),v._v(" 状态。【ACK报文段可以携带数据】")]),v._v(" "),t("li",[v._v("服务端接收到客户端确认后，也进入 "),t("strong",[v._v("ESTABLISHED")]),v._v(" 状态。")])]),v._v(" "),t("p",[t("strong",[v._v("为什么不是二次握手呢？")])]),v._v(" "),t("ul",[t("li",[v._v("主要是为了防止已失效的连接请求报文段突然又传送给服务段，因为产生错误。")])]),v._v(" "),t("blockquote",[t("p",[v._v("异常情况：如果客户端发出的一个连接请求报文没有丢失，只是在某些网络结点长时间"),t("strong",[v._v("滞留")]),v._v("了，直到连接释放后的某个时间才到达服务端。本来这是一个已经失效的报文段，但是服务端会误以为这是客户端发出一次新的连接请求，随后又同意建立连接。所以这就带来了连接资源的浪费了。")])]),v._v(" "),t("p",[t("strong",[v._v("为什么不是四次握手呢？")])]),v._v(" "),t("ul",[t("li",[v._v("三次握手已经足够确认客户端服务端发送和接收的能力，再多用处就不大了。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("TCP 的四次挥手释放")]),v._v(" "),t("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/notes/network/transportLayer/release.jpg"}})]),v._v(" "),t("ul",[t("li",[v._v("双方开始都处于 "),t("strong",[v._v("ESTABLISHED")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("客户端主动发出连接释放报文段，把释放报文段中首部的"),t("strong",[v._v("FIN位 置为1")]),v._v("，自己变成 "),t("strong",[v._v("FIN-WAIT-1")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("服务端收到释放报文段后发出确认，确认报文段中把首部的 "),t("strong",[v._v("ACK位 置为1")]),v._v("，自己变为 "),t("strong",[v._v("CLOSE-WAIT")]),v._v(" 状态。【半关闭状态，即客户端不向服务端发送数据了】")]),v._v(" "),t("li",[v._v("客户端收到服务端的确认后，自己变为 "),t("strong",[v._v("FIN-WAIT-2")]),v._v(" 状态，接着等待服务端发出的连接释放报文段。")]),v._v(" "),t("li",[v._v("服务端发出连接释放报文段，把释放报文段中首部的 "),t("strong",[v._v("FIN 置为1")]),v._v("，自己进入 "),t("strong",[v._v("LAST-ACK")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("客户端接收到释放报文段后发出确认，确认报文段中把首部的 "),t("strong",[v._v("ACK位 置为1")]),v._v("，自己变为 "),t("strong",[v._v("TIME-WAIT")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("服务端接收到客户端确认后变为 "),t("strong",[v._v("CLOSED")]),v._v(" 状态，而客户端需等待 "),t("strong",[v._v("2个MSL")]),v._v(" 后才进入 "),t("strong",[v._v("CLOSED")]),v._v(" 状态。")])]),v._v(" "),t("p",[t("strong",[v._v("为什么客户端CLOSED前需等待2MSL（最长报文段寿命）")])]),v._v(" "),t("ul",[t("li",[t("ol",[t("li",[v._v("为了保证客户端发送的最后一个 "),t("strong",[v._v("ACK 报文段")]),v._v("能够到达服务端。")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("异常情况：如果客户端发送的最后这个 ACK 报文段丢失了，就会造成 LAST-ACK 状态的服务端收不到对客户端发送的 FIN + ACK 报文段的确认。服务端就会超时重传这个 FIN + ACK 报文段，如果客户端发送最后一个 ACK 报文段就直接进入 CLOSED 状态就无法接收服务端重传的报文了，服务端就无法按照正常步骤进入 CLOSED 状态。如果有这个等待2MSL，客户端就可以重传一次确认，最后都可以正常进入 CLOSED 状态。")])]),v._v(" "),t("ul",[t("li",[t("ol",{attrs:{start:"2"}},[t("li",[v._v("确保下一个新的连接中不会出现这次连接的报文段。")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("经过2MSL可以使得本连接持续的时间内所产生的所有报文段都从网络中消失，这样下个新的连接中不会出现这种旧的连接请求报文段。")])])])]),v._v(" "),t("h2",{attrs:{id:"可靠传输的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可靠传输的工作原理"}},[v._v("#")]),v._v(" 可靠传输的工作原理")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("停止等待协议")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("连续ARQ（Automatic Repeat reQuest）协议")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);